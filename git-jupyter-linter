#!/usr/bin/env python3

"""
Run this program from the root of a git repository.
It will format .py and .ipynb files with black,
as well as strip output from .ipynb files.

Modified from https://gist.github.com/JacobHayes/9c86cc650c17a776f4a592fe0b2e7645
See also https://github.com/newren/git-filter-repo/issues/45
and https://github.com/newren/git-filter-repo/blob/master/contrib/filter-repo-demos/lint-history
"""

import subprocess
import sys
import re
import black
import nbformat
import cachetools
import git_filter_repo as fr

blobs_handled = {}
cat_file_process = None
black_cache = cachetools.LRUCache(maxsize=10_000_000, getsizeof=sys.getsizeof)


@cachetools.cached(black_cache)
def blacken(contents):
    try:
        new_contents = black.format_file_contents(
            contents,
            fast=True,
            mode=black.FileMode(
                line_length=88, target_versions={black.TargetVersion.PY38}
            ),
        )
    except black.NothingChanged:
        return contents
    except black.InvalidInput:
        return None
    except:  # once got a blib2to3.pgen2.tokenize.TokenError
        return None
    return new_contents


def filter_py(contents, filename):
    new_contents = blacken(contents.decode())
    if new_contents is None:
        print(f"\nUnable to format {filename}")
        return None
    return new_contents.encode()


def filter_jupyter(contents, filename):
    try:
        nb = nbformat.reads(contents.decode(), nbformat.NO_CONVERT)
    except:
        print(f"\nUnable to parse notebook {filename}")
        return None
    failed_cells = 0
    for cell in nb['cells']:
        if cell['cell_type'] != 'code':
            continue
        cell['output'] = []
        cell['outputs'] = []
        source = cell['source']
        source = re.sub('^%', '#%#', source, flags=re.M)
        new_source = blacken(source)
        if new_source is not None:
            new_source = re.sub('^#%#', '%', new_source, flags=re.M)
            cell['source'] = new_source
        else:
            failed_cells += 1
    if failed_cells:
        print(f"\nFailed to format {failed_cells} cells in notebook {filename}")
    new_contents = nbformat.writes(nb)
    return new_contents.encode()


filetype_filters = {'py': filter_py, 'ipynb': filter_jupyter}


def filter_commit(commit, metadata):
    for change in commit.file_changes:
        filename = change.filename.decode()
        extension = filename.split('.')[-1].lower()
        if change.blob_id in blobs_handled:
            change.blob_id = blobs_handled[change.blob_id]
        elif extension in filetype_filters.keys():
            # change.blob_id is None for deleted files (ex: change.type=b'D')
            if change.blob_id is None:
                assert change.type == b'D'
                continue
            # Get the old blob contents
            cat_file_process.stdin.write(change.blob_id + b"\n")
            cat_file_process.stdin.flush()
            objhash, objtype, objsize = cat_file_process.stdout.readline().split()
            contents_plus_newline = cat_file_process.stdout.read(int(objsize) + 1)
            # Reformat into a new blob
            if extension in filetype_filters.keys():
                new_contents = filetype_filters[extension](
                    contents_plus_newline, filename
                )
                if new_contents is None:
                    continue
            else:
                continue
            # Insert the new file into the filter's stream, and remove the tempfile
            blob = fr.Blob(new_contents)
            repo_filter.insert(blob)
            # Record our handling of the blob and use it for this change
            blobs_handled[change.blob_id] = blob.id
            change.blob_id = blob.id


args = fr.FilteringOptions.default_options()
args.force = True
cat_file_process = subprocess.Popen(
    ['git', 'cat-file', '--batch'], stdin=subprocess.PIPE, stdout=subprocess.PIPE
)
repo_filter = fr.RepoFilter(args, commit_callback=filter_commit)
repo_filter.run()
cat_file_process.stdin.close()
cat_file_process.wait()
